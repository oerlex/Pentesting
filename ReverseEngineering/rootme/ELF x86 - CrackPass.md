After firing up radare2 and stepping doing the regular
```console
aaaa
afl
s main
pdf 
```
I could see a anti debugging mechanism
```console
 0x08048685      e852fdffff     call sym.imp.ptrace
|           0x0804868a      85c0           test eax, eax
|       ,=< 0x0804868c      7911           jns 0x804869f
|       |   0x0804868e      c70424cf8704.  mov dword [esp], str.Don_t_use_a_debuguer ; [0x80487cf:4]=0x276e6f44 ; "Don't use a debuguer !"
|       |   0x08048695      e882fdffff     call sym.imp.puts           ; int puts(const char *s)
|       |   0x0804869a      e80dfdffff     call sym.imp.abort          ; void abort(void)
|       `-> 0x0804869f      83fb02         cmp ebx, 2                  ; 2
|       ,=< 0x080486a2      7411           je 0x80486b5
|       |   0x080486a4      c704240c8804.  mov dword [esp], str.You_must_give_a_password_for_use_this_program ; [0x804880c:4]=0x20756f59 ; "You must give a password for use this program !"
|       |   0x080486ab      e86cfdffff     call sym.imp.puts           ; int puts(const char *s)
|       |   0x080486b0      e8f7fcffff     call sym.imp.abort          ; void abort(void)
|       `-> 0x080486b5      8b4604         mov eax, dword [esi + 4]    ; [0x4:4]=-1 ; 4
|           0x080486b8      890424         mov dword [esp], eax

```
Which verified to be active when trying to debug the application the following way:
```console
[0xf7f250b0]> dc
Don't use a debuguer !
child stopped with signal 6
[+] SIGNAL 6 errno=0 addr=0x00001d13 code=-6 ret=0
```
We will show how to patch this later but lets follow the code.  
Next, the application calls a function which appears to be the validating entity.
```console
/ (fcn) sub.__ctype_b_loc_80485a5 163
|   sub.__ctype_b_loc_80485a5 (int arg_8h);
|           ; var int local_1088h @ ebp-0x1088
|           ; var int local_1008h @ ebp-0x1008
|           ; arg int arg_8h @ ebp+0x8
|           ; var int local_4h @ esp+0x4
|           ; CALL XREF from main (0x80486bb)
|           0x080485a5      55             push ebp
|           0x080485a6      89e5           mov ebp, esp
|           0x080485a8      56             push esi
|           0x080485a9      53             push ebx
|           0x080485aa      81ec90100000   sub esp, 0x1090
|           0x080485b0      8b7508         mov esi, dword [arg_8h]     ; [0x8:4]=-1
|           0x080485b3      0fb61e         movzx ebx, byte [esi]
|           0x080485b6      84db           test bl, bl
|       ,=< 0x080485b8      742e           je 0x80485e8
|       |   0x080485ba      e83dfeffff     call sym.imp.__ctype_b_loc
|       |   0x080485bf      8b08           mov ecx, dword [eax]
|       |   0x080485c1      89f2           mov edx, esi
|      .--> 0x080485c3      0fbec3         movsx eax, bl
|      :|   0x080485c6      f6044108       test byte [ecx + eax*2], 8
|     ,===< 0x080485ca      7511           jne 0x80485dd
|     |:|   0x080485cc      c70424a58704.  mov dword [esp], str.Bad_password ; [0x80487a5:4]=0x20646142 ; "Bad password !"
|     |:|   0x080485d3      e844feffff     call sym.imp.puts           ; int puts(const char *s)
|     |:|   0x080485d8      e8cffdffff     call sym.imp.abort          ; void abort(void)
|     `---> 0x080485dd      0fb65a01       movzx ebx, byte [edx + 1]   ; [0x1:1]=255 ; 1
|      :|   0x080485e1      83c201         add edx, 1
|      :|   0x080485e4      84db           test bl, bl
|      `==< 0x080485e6      75db           jne 0x80485c3
|       `-> 0x080485e8      89742404       mov dword [local_4h], esi
|           0x080485ec      8db5f8efffff   lea esi, dword [local_1008h]
|           0x080485f2      893424         mov dword [esp], esi
|           0x080485f5      e8fafeffff     call fcn.080484f4
|           0x080485fa      8d9d78efffff   lea ebx, dword [local_1088h]
|           0x08048600      895c2404       mov dword [local_4h], ebx
|           0x08048604      c70424609904.  mov dword [esp], str.THEPASSWORDISEASYTOCRACK ; [0x8049960:4]=0x50454854 ; "THEPASSWORDISEASYTOCRACK"
|           0x0804860b      e80cffffff     call sub..2x_804851c
|           0x08048610      89742404       mov dword [local_4h], esi
|           0x08048614      891c24         mov dword [esp], ebx
|           0x08048617      e810feffff     call sym.imp.strcmp         ; int strcmp(const char *s1, const char *s2)
|           0x0804861c      85c0           test eax, eax
|       ,=< 0x0804861e      7512           jne 0x8048632
|       |   0x08048620      895c2404       mov dword [local_4h], ebx
|       |   0x08048624      c70424e88704.  mov dword [esp], str.Good_work__the_password_is_:______s ; [0x80487e8:4]=0x646f6f47 ; "Good work, the password is : \n\n%s\n"
|       |   0x0804862b      e8dcfdffff     call sym.imp.printf         ; int printf(const char *format)
|      ,==< 0x08048630      eb0c           jmp 0x804863e
|      |`-> 0x08048632      c70424b48704.  mov dword [esp], str.Is_not_the_good_password ; [0x80487b4:4]=0x6e207349 ; "Is not the good password !"
|      |    0x08048639      e8defdffff     call sym.imp.puts           ; int puts(const char *s)
|      |    ; CODE XREF from sub.__ctype_b_loc_80485a5 (0x8048630)
|      `--> 0x0804863e      81c490100000   add esp, 0x1090
|           0x08048644      5b             pop ebx
|           0x08048645      5e             pop esi
|           0x08048646      5d             pop ebp
\           0x08048647      c3             ret

```
We can see that there are several checks. Lets look into the first "JE-BLOCK". There we can see that the function "__ctype_b_loc" is called but to be honest, this would require a lot of time of tracing where our entered password (int arg_8h @ ebp+0x8) is eventually modified. So I fired up GHIDRA to see if we can get some Pseudo-Code which would make things easier. And see:
```C
void FUN_080485a5(char *param_1)

{
  ushort **ppuVar1;
  int iVar2;
  char *pcVar3;
  char cVar4;
  char local_108c [128];
  char local_100c [4096];
  
  cVar4 = *param_1;
  if (cVar4 != '\0') {
    ppuVar1 = __ctype_b_loc();
    pcVar3 = param_1;
    do {
      if ((*(byte *)(*ppuVar1 + cVar4) & 8) == 0) {
        puts("Bad password !");
                    /* WARNING: Subroutine does not return */
        abort();
      }
      cVar4 = pcVar3[1];
      pcVar3 = pcVar3 + 1;
    } while (cVar4 != '\0');
  }
  FUN_080484f4((int)local_100c,param_1);
  FUN_0804851c((byte *)s_THEPASSWORDISEASYTOCRACK_08049960,local_108c);
  iVar2 = strcmp(local_108c,local_100c);
  if (iVar2 == 0) {
    printf("Good work, the password is : \n\n%s\n",local_108c);
  }
  else {
    puts("Is not the good password !");
  }
  return;
}
```
Here we can trace our param_1 way easier and see that the first if-block is not modifying the parameter, but only validates characters.  
After that we have two function calls.  
Nr.1 ```FUN_080484f4((int)local_100c,param_1);``` which looks the following (param_1 being the entered password on function call but param_2 in the function declaration):
```c
void FUN_080484f4(int param_1,char *param_2)

{
  int iVar1;
  char cVar2;
  
  cVar2 = *param_2;
  if (cVar2 != '\0') {
    iVar1 = 0;
    do {
      *(char *)(param_1 + iVar1) = cVar2;
      cVar2 = param_2[iVar1 + 1];
      iVar1 = iVar1 + 1;
    } while (cVar2 != '\0');
  }
  return;
}
```
This is also not affecting our password but rather copies it to a memory location at local_100c.  
Next, the function ```FUN_0804851c((byte *)s_THEPASSWORDISEASYTOCRACK_08049960,local_108c);``` is called. This function takes the String "THEPASSWORDISEASYTOCRACK" and runs it through some algorithm yielding the password the user requires to input in order to get a success message. This password is stored at lcoal_108c but we can spare the details...
More importantly is the next code snippet.
```c
  iVar2 = strcmp(local_108c,local_100c);
  if (iVar2 == 0) {
    printf("Good work, the password is : \n\n%s\n",local_108c);
  }
  else {
    puts("Is not the good password !");
  }
  return;
  ```
  There these two passwords are compared and if they are equal the correct password will be printed out. That means that in the end it does not matter what we input. We only have to disable all the checks and enter an arbitary password. We can do this by patching three different pieces in the Assembly code.
  
#1 The Anti-Debugging Mechanism  
```console
 0x08048685      e852fdffff     call sym.imp.ptrace
|           0x0804868a      85c0           test eax, eax
|       ,=< 0x0804868c      7911           jns 0x804869f
|       |   0x0804868e      c70424cf8704.  mov dword [esp], str.Don_t_use_a_debuguer ; [0x80487cf:4]=0x276e6f44 ; "Don't use a debuguer !"
|       |   0x08048695      e882fdffff     call sym.imp.puts           ; int puts(const char *s)
|       |   0x0804869a      e80dfdffff     call sym.imp.abort          ; void abort(void)
|       `-> 0x0804869f      83fb02         cmp ebx, 2                  ; 2
|       ,=< 0x080486a2      7411           je 0x80486b5
|       |   0x080486a4      c704240c8804.  mov dword [esp], str.You_must_give_a_password_for_use_this_program ; [0x804880c:4]=0x20756f59 ; "You must give a password for use this program !"
|       |   0x080486ab      e86cfdffff     call sym.imp.puts           ; int puts(const char *s)
|       |   0x080486b0      e8f7fcffff     call sym.imp.abort          ; void abort(void)
|       `-> 0x080486b5      8b4604         mov eax, dword [esi + 4]    ; [0x4:4]=-1 ; 4
|           0x080486b8      890424         mov dword [esp], eax

```
So we need to disable this check by changing jns (which is a conditional check and means "Jump if Not Signed") which is depended on the return value of ptrace at address 0x08048685. We do this by changing JNS to JMP.  

#2 The \_ctype_b_loc if-statement  
```console
  0x080485b6      84db           test bl, bl
|       ,=< 0x080485b8      742e           je 0x80485e8
|       |   0x080485ba      e83dfeffff     call sym.imp.__ctype_b_loc
|       |   0x080485bf      8b08           mov ecx, dword [eax]
|       |   0x080485c1      89f2           mov edx, esi
|      .--> 0x080485c3      0fbec3         movsx eax, bl
|      :|   0x080485c6      f6044108       test byte [ecx + eax*2], 8
|     ,===< 0x080485ca      7511           jne 0x80485dd
|     |:|   0x080485cc      c70424a58704.  mov dword [esp], str.Bad_password ; [0x80487a5:4]=0x20646142 ; "Bad password !"
|     |:|   0x080485d3      e844feffff     call sym.imp.puts           ; int puts(const char *s)
|     |:|   0x080485d8      e8cffdffff     call sym.imp.abort          ; void abort(void)
|     `---> 0x080485dd      0fb65a01       movzx ebx, byte [edx + 1]   ; [0x1:1]=255 ; 1
|      :|   0x080485e1      83c201         add edx, 1
|      :|   0x080485e4      84db           test bl, bl
|      `==< 0x080485e6      75db           jne 0x80485c3
|       `-> 0x080485e8      89742404       mov dword [local_4h], esi
|           0x080485ec      8db5f8efffff   lea esi, dword [local_1008h]
```
Replace JE with JMP at 0x0808485b8. This is possible because our entered password is not affected.

#3 The password check
```console
        =< 0x0804861e      7512           jne 0x8048632
       |   0x08048620      895c2404       mov dword [local_4h], ebx
       |   0x08048624      c70424e88704.  mov dword [esp], str.Good_work__the_password_is_:______s ; [0x80487e8:4]=0x646f6f47 ; "Good work, the password is : \n\n%s\n"
       |   0x0804862b      e8dcfdffff     call sym.imp.printf         ; int printf(const char *format)
       ,==< 0x08048630      eb0c           jmp 0x804863e
       |`-> 0x08048632      c70424b48704.  mov dword [esp], str.Is_not_the_good_password ; [0x80487b4:4]=0x6e207349 ; "Is not the good password !"
       |    0x08048639      e8defdffff     call sym.imp.puts           ; int puts(const char *s)
       |    ; CODE XREF from sub.__ctype_b_loc_80485a5 (0x8048630)
       `--> 0x0804863e      81c490100000   add esp, 0x1090
```
Here we do not want to jump since it will yield the "Is not the good password" message. So we have to invert the JNE/JNZ by instruction by changing it to JZ/JE.  
Now we should be able to recompile and run the program to get the flag. But weirdly I could not open radare2 in write mode since it would give me the error:  
```console
radare2 -w Crack 12345
r_io_create: Permission denied.
WARNING: r_buf_cpy: assertion 'b && !b->empty' failed (line 117)
WARNING: r_buf_cpy: assertion 'b && !b->empty' failed (line 117)
WARNING: r_buf_cpy: assertion 'b && !b->empty' failed (line 117)
WARNING: r_buf_cpy: assertion 'b && !b->empty' failed (line 117)
[0x00000000]> 
```
or without passing an argument
```console
radare2 -w Crack 
r_io_create: Permission denied.
[w] Cannot open 'Crack' for writing.
```
Any input on this is greatly appreciated :).  
So I decided to patch the file in GHIDRA which unfortunately resulted in a segementation error. A bit sad I thought I would give it a last google search and found this --> https://github.com/NationalSecurityAgency/ghidra/issues/19 which I tried and voilÃ¡!  
Apparently does GHIDRA have a bug which you can resolve by importing the binary as raw and set the language manually. This made the code badly readable for me but made it possible to patch, export, and run it. 
```console
./Crack3.2.bin 12345
Good work, the password is : 

ff07031d6fb052490149f44b1d5e94f1592b6bac93c06ca9
```
Shoutout to the guide of Denis --> https://dev.to/denisnutiu/root-me-elf-crackpass-with-nsas-ghidra-403o which helped me at some problems.

