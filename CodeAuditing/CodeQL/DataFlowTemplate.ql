/**
 * @name An Injection
 * @description Checking for an injection whose parameters might be modifiable
 * @kind path-problem
 * @id anInjection
 * @problem.severity error
 * @security-severity 9.0
 */

import javascript
import DataFlow::PathGraph


private class ConfigFileName extends DataFlow::Node instanceof DataFlow::PropRef {
	 ConfigFileName() {
		this.toString().matches("%config%")			//Filter all PropRefs by this expression to find config files
	 }
}

private class QueryCall extends DatabaseAccess, DataFlow::MethodCallNode{
    QueryCall() {
      exists(API::Node recv |
        this = recv.getMember(["query", "execute", "raw" , "select", "delete", "update"]).getACall()
      )
    }
}

//Config class ()
class MyConfigClass extends TaintTracking::Configuration {
	MyConfigClass() { this = "AnInjection" }

    // A source is usually defined to first place we want to inspect the data flow
    // Example in web application can be requests or configuration files
	override predicate isSource(DataFlow::Node source) {
		source = any(ClientRequest r).getAResponseDataNode() or     // Filters client requests that have a response
		source instanceof RemoteFlowSource or 		                // Kind of a default. Defines a range of sources that come from external nodes
		source instanceof ConfigFileName                            // Our own class defined above
	}

   // Sinks are the last place within the data flow we want to trace. It is where data from the source ends up.
   // In order to find injections these are commonly database queries, os.exec-ish statements, but could also be requests to other servers (SSRF!)
	override predicate isSink(DataFlow::Node sink) {
	    sink = any(SystemCommandExecution sys).getACommandArgument() or // CMDi
	    sink = any(QueryCall qc).getAQueryArgument() or                 // SQLi
	    sink instanceof DatabaseAccess                                  // SQLi (our own class defined above)
	    sink = any(ClientRequest r).getUrl()                            // SSRF
	}
}

// This is the actual query
// "from" defines the variables used in the query and their type
from MyConfigClass cfg, DataFlow::PathNode source, DataFlow::PathNode sink, DataFlow::Node sourceNode

// "where" is the conditional part. Here we can further filter what's to be displayed in the results
where cfg.hasFlowPath(source, sink) and    
sourceNode = source.getNode()

// "select" is the part that defines whats shown in the result set
select sink.getNode(), source, sink,
"Potential injection from \"" + sourceNode.toString() + "\" (" + sourceNode.getFile().getBaseName() + ":" +
sourceNode.getStartLine() + ":" + sourceNode.getStartColumn() + ")"
